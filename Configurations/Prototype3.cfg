
/* my test app*/
+StateMachine = {
	Class = StateMachine
	+INITIAL = {
		Class = ReferenceContainer
		+Start = {
			Class = StateMachineEvent
			NextState = "WAITSTANDBY"
			NextStateError = "ERROR"
            +PrepareNextStateOnOurRTApp = {
        		Class = Message
        		Destination = MyApp
        		Mode = ExpectsReply
        		Function = PrepareNextState
        		+Parameters = {
        			Class = ConfigurationDatabase
        			param1 = WaitStandby
        		}
        	}

	        +StartNextStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StartNextStateExecution
        		Mode = ExpectsReply
	        }		
		}
	}
	
	+WAITSTANDBY = {
		Class = ReferenceContainer
		/* GoOffline is one of command to be executed.*/
		+GoOffline = {
			Class = StateMachineEvent
			NextState = "OFFLINE"
			NextStateError = "ERROR"
            +PrepareNextStateOnOurRTApp = {
        		Class = Message
        		Destination = MyApp
        		Mode = ExpectsReply
        		Function = PrepareNextState
        		+Parameters = {
        			Class = ConfigurationDatabase
        			param1 = Offline
        		}
        	}
			+StopCurrentStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StopCurrentStateExecution
        		Mode = ExpectsReply
	        }
	        +StartNextStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StartNextStateExecution
        		Mode = ExpectsReply
	        }
		}
		+GoError = {  /* This is a line to receive event from RT Application */
			Class = StateMachineEvent
			NextState = "ERROR"
			NextStateError = "ERROR"
			+PrepareNextStateOnOurRTApp = { /*This code is executed in SM*/
				Class = Message
				Destination = MyApp
				Mode = ExpectsReply
				Function = PrepareNextState
				+Parameters = {
					Class = ConfigurationDatabase
					param1 = Error
				}
			}
			+StopCurrentStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StopCurrentStateExecution
        		Mode = ExpectsReply
	        }
	        +StartNextStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StartNextStateExecution
        		Mode = ExpectsReply
	        }
		}
	}
	
	+OFFLINE = {
		Class = ReferenceContainer
		/* GoOffline is one of command to be executed.*/
		+GoPreHeating = {
			Class = StateMachineEvent
			NextState = "PREHEATING"
			NextStateError = "ERROR"
            +PrepareNextStateOnOurRTApp = {
        		Class = Message
        		Destination = MyApp
        		Mode = ExpectsReply
        		/* The following function is executed in RT app.*/
        		Function = PrepareNextState
        		+Parameters = {
        			Class = ConfigurationDatabase
        			param1 = PreHeating
        		}
        	}
			+StopCurrentStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StopCurrentStateExecution
        		Mode = ExpectsReply
	        }
	        +StartNextStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StartNextStateExecution
        		Mode = ExpectsReply
	        }
		}
		+GoError = {  /* This is a line to receive event from RT Application */
			Class = StateMachineEvent
			NextState = "ERROR"
			NextStateError = "ERROR"
			+PrepareNextStateOnOurRTApp = { /*This code is executed in SM*/
				Class = Message
				Destination = MyApp
				Mode = ExpectsReply
				Function = PrepareNextState
				+Parameters = {
					Class = ConfigurationDatabase
					param1 = Error
				}
			}
			+StopCurrentStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StopCurrentStateExecution
        		Mode = ExpectsReply
	        }
	        +StartNextStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StartNextStateExecution
        		Mode = ExpectsReply
	        }
		}
	}	
	
	+PREHEATING = {
		Class = ReferenceContainer
		/* GoOffline is one of command to be executed.*/
		+GoWaitStandby = {
			Class = StateMachineEvent
			NextState = "WAITSTANDBY"
			NextStateError = "ERROR"
            +PrepareNextStateOnOurRTApp = {
        		Class = Message
        		Destination = MyApp
        		Mode = ExpectsReply
        		/* The following function is executed in RT app.*/
        		Function = PrepareNextState
        		+Parameters = {
        			Class = ConfigurationDatabase
        			param1 = WaitStandby
        		}
        	}
			+StopCurrentStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StopCurrentStateExecution
        		Mode = ExpectsReply
	        }
	        +StartNextStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StartNextStateExecution
        		Mode = ExpectsReply
	        }
		}
		+GoError = {  /* This is a line to receive event from RT Application */
			Class = StateMachineEvent
			NextState = "ERROR"
			NextStateError = "ERROR"
			+PrepareNextStateOnOurRTApp = { /*This code is executed in SM*/
				Class = Message
				Destination = MyApp
				Mode = ExpectsReply
				Function = PrepareNextState
				+Parameters = {
					Class = ConfigurationDatabase
					param1 = Error
				}
			}
			+StopCurrentStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StopCurrentStateExecution
        		Mode = ExpectsReply
	        }
	        +StartNextStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StartNextStateExecution
        		Mode = ExpectsReply
	        }
		}
	}	

	+ERROR = {
		Class = ReferenceContainer
		/* GoOffline is one of command to be executed.*/
		+GoReset = {
			Class = StateMachineEvent
			NextState = "WAITSTANDBY"
			NextStateError = "ERROR"
            +PrepareNextStateOnOurRTApp = {
        		Class = Message
        		Destination = MyApp
        		Mode = ExpectsReply
        		/* The following function is executed in RT app.*/
        		Function = PrepareNextState
        		+Parameters = {
        			Class = ConfigurationDatabase
        			param1 = WaitStandby
        		}
        		
        	}
        	+StopCurrentStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StopCurrentStateExecution
        		Mode = ExpectsReply
	        }
	        +StartNextStateExecution = {
        		Class = Message
        		Destination = MyApp 
        		Function = StartNextStateExecution
        		Mode = ExpectsReply
	        }
		}
		
	}	
}	

+MyApp = {
	Class = RealTimeApplication
	+Functions = {
	    Class = ReferenceContainer
	    +TimerGAM = {
            Class = IOGAM
            InputSignals = {
                Counter = {
                    DataSource = Timer
                    Type = uint32
                    Frequency = 1  /* Hz */
                }
            }
            OutputSignals = {
                Counter = {
                    DataSource = Display
                    Type = int32
                }
            }
        }
        +WaitStandbyMessageGAM = {
            Class = JAMessageGAM /*JAMessageGAM will be developed.*/
            InputSignals = {
                Standby = { /* Signal name*/
                    DataSource = EPICSCAInput
                    Type = uint32
                }
                
            }
            /* following message is sent when signal state (standby) becomes 1.*/
            +Event = {
        		Class = Message
        		Destination = StateMachine 
        		Function = GoOffline  /* The GoOffline event in State Machine is called.*/
        		Mode = ExpectsReply
	        }
        }
        
        +OfflineMessageGAM = {
        /* Check two parameter, tell both signal are true. */
            Class = JAMessageGAM /*JAMessageGAM will be developed.*/
            Operation = AND
            InputSignals = {
                Ready1 = { /* Signal name*/
                    DataSource = EPICSCAInput
                    Type = uint32
                }
                Ready2 = { /* Signal name*/
                    DataSource = EPICSCAInput
                    Type = uint32
                }
                
            }
            /* following message is sent when signal state (standby) becomes 1.*/
            +Event = {
        		Class = Message
        		Destination = StateMachine 
        		Function = GoPreHeating  /* The GoOffline event in State Machine is called.*/
        		Mode = ExpectsReply
	        }
        }
        +ErrorDetectGAM = {
        	Class = JAMessageGAM
        	Operation = OR
        	InputSignals = {
        		Error1 = {/*APS error signal */
        			DataSource = EPICSCAInput
        			Type = uint32
        		}
        		Error2 = {/*BPS error signal*/
        			DataSource = EPICSCAInput
        			Type = uint32
        		}
        	}
        	/*When any device emit error, sm go to error state*/
        	+Event = {
        		Class = Message
        		Destination = StateMachine
        		Function = GoError /*State machine needs to receive GoError Event*/
        		Mode = ExpectsReply        	
        	}
        }
        +WritePVGAM = {
        	Class = ConstantGAM
        	OutputSignals = {
        		APSStop = {
        			DataSource = "EPICSCAOutput"
        			Type = uint32
        			Default = 1
        		}
        		BPSStop = {
        		    DataSource = "EPICSCAOutput"
        			Type = uint32
        			Default = 1
        		}
        	}
        }
        +ResetErrorGAM = {
        	Class = JAMessageGAM
        	InputSignals = {
        		ResetError = {/*Detect reset command*/
        			DataSource = EPICSCAInput
        			Type = uint32
        		}
        	}
        	/*When any device emit error, sm go to error state*/
        	+Event = {
        		Class = Message
        		Destination = StateMachine
        		Function = GoReset /*State machine needs to receive GoError Event*/
        		Mode = ExpectsReply        	
        	}        
        }
	}
    +Data = {
        Class = ReferenceContainer
        DefaultDataSource = DDB1 
        +Timer = {
            Class = LinuxTimer
            SleepNature = "Default"
            SleepPercentage = 30
            ExecutionMode = RealTimeThread
            CPUMask = 0x1
            Signals = {
                Counter = {
                    Type = uint32
                }
                Time = {
                    Type = uint32
                }
            }
        }
        +EPICSCAInput = {
            Class = "EPICSCA::EPICSCAInput"
            CPUMask = "2" /* run on CPU 3 <-- 0100 */
            StackSize = "10000000"
            Signals = {
                Standby = {
                    PVName = "EC-GN-P01-GPF:PLC4110-YTS-ST1R"
                }
                Ready1 = {
                    PVName = "EC-GN-P01-GBF-MCPS:PSU2120-ACT-RB"
                }
                Ready2 = {
                    PVName = "EC-GN-P01-GAF-GCPS:PSU2130-ACT-RB"
                }
                Error1 = {
                	PVName = "EC-GN-P01-PA1F:PSU3000-YFLT"
                }
                Error2 = {
                	PVName = "EC-GN-P01-PB1F:PSU1000-YFLT"
                }
                ResetError = {
	        		PVName = "EC-GN-P01-GPF:STAT-RST-FLT"
	        	}
            }
        }
        +EPICSCAOutput = {
        	Class = "EPICSCA::EPICSCAOutput"
        	CPUMask = "2"
        	StackSize = "10000000"
        	NumberOfBuffers = 2
        	Signals = {
	        	APSStop = {
	        		PVName = "EC-GN-P01-PA1F:PSU3000-CTRP"
	        	}
	        	BPSStop = {
	        		PVName = "EC-GN-P01-PB1F:PSU1000-CTRP"
	        	}
        	}
        }

        +Display = {
            Class = LoggerDataSource
        }
        +Timings = {
            Class = TimingDataSource
        }
    }
    +States = {
        Class = ReferenceContainer
        +WaitStandby = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = {
                    Class = RealTimeThread
                    /* Add GAMs to be executed.*/
                    Functions = {TimerGAM WaitStandbyMessageGAM ErrorDetectGAM}
                    CPUMask = 0x1
                }
            }
        }
        +Offline = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = {
                    Class = RealTimeThread
                    /* Add GAMs to be executed.*/
                    Functions = {TimerGAM OfflineMessageGAM ErrorDetectGAM}
                    CPUMask = 0x1
                }
            }
        }
        +PreHeating = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = {
                    Class = RealTimeThread
                    /* Add GAMs to be executed.*/
                    Functions = {TimerGAM ErrorDetectGAM}
                    CPUMask = 0x1
                }
            }
        }
        +Error = {
        	Class = RealTimeState
        	+Threads = {
        		Class = ReferenceContainer
        		+Thread1 = {
        			Class = RealTimeThread
        			Functions = {WritePVGAM ResetErrorGAM}
        			CPUMask = 0x1
        		}
        	}
        }
    }
    +Scheduler = {
        Class = GAMScheduler
        TimingDataSource = Timings
    }
}